package com.leokongwq.geektime.stringmatch;

/**
 * @author : jiexiu
 * @date : 2020-06-22 19:28
 *
 * RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的
 *
 * RK 算法的思路是这样的：
 *
 * 我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。
 * 如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。
 * 因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。
 *
 * 我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。
 * 我假设字符串中只包含 a～z 这 26 个小写字符，我们用二十六进制来表示一个字符串，对应的哈希值就是二十六进制数转化成十进制的结果。
 * cba = 2 * 26 * 26 + 1 * 26 + 0 * 1
 *
 * 这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系。
 * 相邻两个子串 s[i-1]和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，
 * 也就是说，我们可以使用 s[i-1]的哈希值很快的计算出 s[i]的哈希值
 **/
public class RKMatcher {


}
