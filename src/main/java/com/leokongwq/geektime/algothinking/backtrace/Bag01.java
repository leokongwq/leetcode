package com.leokongwq.geektime.algothinking.backtrace;

/**
 * @author : jiexiu
 * @date : 2020-06-29 12:51
 * <p>
 * 0-1 背包是非常经典的算法问题，很多场景都可以抽象成这个问题模型。这个问题的经典解法是动态规划，不过还有一种简单但没有那么高效的解法，那就是今天讲的回溯算法。
 * 如何用回溯法解决这个问题。0-1 背包问题有很多变体，我这里介绍一种比较基础的。
 * <p>
 * 我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。
 * 在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？
 * <p>
 * 实际上，背包问题我们在贪心算法那一节，已经讲过一个了，不过那里讲的物品是可以分割的，我可以装某个物品的一部分到背包里面。
 * 今天讲的这个背包问题，物品是不可分割的，要么装要么不装，所以叫 0-1 背包问题。
 * <p>
 * <p>
 * 对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2^n 种。
 * 去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。
 * 不过，我们如何才能不重复地穷举出这 2^n 种装法呢？
 * <p>
 * 这里就可以用回溯的方法。我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。
 * 先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。描述起来很费劲，
 * 这里还稍微用到了一点搜索剪枝的技巧，就是当发现已经选择的物品的重量超过 Wkg 之后，我们就停止继续探测剩下的物品。你可以看我写的具体的代码。
 *
 * 时间复杂度 O(2^n)
 **/
public class Bag01 {

	/**
	 * 存储背包中物品总重量的最大值
	 */
	public int maxW = Integer.MIN_VALUE;

	/**
	 * 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：f(0, 0, a, 10, 100)
	 * @param i 表示考察到哪个物品了；
	 * @param cw cw表示当前已经装进去的物品的重量和
	 * @param items 表示每个物品的重量
	 * @param n n表示物品个数
	 * @param w w背包重量
	 */
	public void f(int i, int cw, int[] items, int n, int w) {
		// cw == w表示装满了（cw不可能大于背包重量，因为每次选择物品时都进行了判断）; i == n 表示已经考察完所有的物品
		if (cw == w || i == n) {
			if (cw > maxW) {
				maxW = cw;
			}
			System.out.println("背包重量：" + cw);
			return;
		}
		//针对每个物品，选择 或 不选择
		//直接不选择当前物品 i
		f(i + 1, cw, items, n, w);
		// 判断选择当前物品i
		if (cw + items[i] <= w) {
			//选择当前物品，并考虑下一下
			f(i + 1, cw + items[i], items, n, w);
		}
	}


	public static void main(String[] args) {
		Bag01 bag01 = new Bag01();
		int[] items = new int[]{10, 5, 3, 88, 77};
		bag01.f(0, 0, items, 5, 100);
	}

}
