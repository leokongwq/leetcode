package com.leokongwq.geektime.advanced;

/**
 * @author : jiexiu
 * @date : 2020-07-04 00:11
 *
 * 网页爬虫是搜索引擎中的非常重要的系统，负责爬取几十亿、上百亿的网页。爬虫的工作原理是，通过解析已经爬取页面中的网页链接，然后再爬取这些链接对应的网页。
 * 而同一个网页链接有可能被包含在多个页面中，这就会导致爬虫在爬取的过程中，重复爬取相同的网页。如果你是一名负责爬虫的工程师，你会如何避免这些重复的爬取呢？
 *
 * 解决方案1：
 * 通过 hash表，红黑树，跳表此类动态的数据结构 可以支持快速的查找和插入，但是内存消耗太大了。单机很难满足存储和计算要求。
 * 可以利用分治法，将不同类型的网址分散到一个集群中，由多台机器负责存储和计算。
 *
 * 位图
 *
 * 我们有 1 千万个整数（不重复），整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？
 *
 * 解决方案: 通过建立一个大小为1亿的位图，也就是一个bit位个数为1亿的结构，直接通过下标访问，如果下标位置的bit位为1表示存在
 * 为0表示不存在。
 * 拓展：可以通过位图来排序，具体思路如下：
 * 1. 遍历数组，数组元素的值对应位图的下标，将下标设置为1
 * 2. 遍历位图，将bit位为1的下标输出即可。
 * 3. 如果有重复元素，将重复元素通过额外的 HaspMap来保存，key为数组元素，value为出现次数
 *
 * 注意：使用bitmap时，元素的最大值不能过大，否则会很浪费空间。例如 1000w个整数，范围在 1 到 10亿
 *
 * 解决方案二：BloomFilter
 *
 * 将 数组中的元素通过函数f(x) 变为 范围为 1亿内的数，
 * 比如我们把哈希函数设计成 f(x)=x%n。其中，x 表示数字，n 表示位图的大小（1 亿），也就是，对数字跟位图的大小进行取模求余。
 * 这样就可以节省内存空间，但是会有hash冲突，此时就需要 BloomFilter登场了
 *
 * 我们使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值，我们分别记作 X1​，X2​，X3​，…，XK​。
 * 我们把这 K 个数字作为位图中的下标，将对应的 BitMap[X1​]，BitMap[X2​]，BitMap[X3​]，…，BitMap[XK​]都设置成 true，
 * 也就是说，我们用 K 个二进制位，来表示一个数字的存在。当我们要查询某个数字是否存在的时候，我们用同样的 K 个哈希函数，
 * 对这个数字求哈希值，分别得到 Y1​，Y2​，Y3​，…，YK​。我们看这 K 个哈希值，对应位图中的数值是否都为 true，如果都是 true，
 * 则说明，这个数字存在，如果有其中任意一个不为 true，那就说明这个数字不存在。
 *
 * 尽管采用 K 个哈希函数之后，两个数字哈希冲突的概率降低了，但是，这种处理方式又带来了新的问题，那就是容易误判
 *
 * 布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；
 * 如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，
 * 那就可以将这种误判的概率降到非常低。
 *
 *
 * 我们用布隆过滤器来记录已经爬取过的网页链接，假设需要判重的网页有 10 亿，那我们可以用一个 10 倍大小的位图来存储，也就是 100 亿个二进制位，
 * 换算成字节，那就是大约 1.2GB。之前我们用散列表判重，需要至少 100GB 的空间。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多。
 *
 **/
public class BitMap {

	// Java中char类型占16bit，也即是2个字节
	private char[] bytes;
	private int nbits;

	public BitMap(int nbits) {
		this.nbits = nbits;
		this.bytes = new char[nbits / 16 + 1];
	}

	public void set(int k) {
		if (k > nbits) {
			return;
		}
		int byteIndex = k / 16;
		int bitIndex = k % 16;
		// 1 左移 bitIndex 位
		bytes[byteIndex] |= (1 << (bitIndex ));
	}

	public boolean get(int k) {
		if (k > nbits) {
			return false;
		}
		int byteIndex = k / 16;
		int bitIndex = k % 16;
		return (bytes[byteIndex] & (1 << (bitIndex ))) != 0;
	}

	public static void main(String[] args) {
		BitMap bitMap = new BitMap(32);
		bitMap.set(32);
		bitMap.set(31);
		System.out.println(bitMap.get(32));
	}
}
